"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _got = _interopRequireDefault(require("got"));

var _sharp = _interopRequireDefault(require("sharp"));

var _lodash = _interopRequireDefault(require("lodash.find"));

var _lodash2 = _interopRequireDefault(require("lodash.uniqby"));

var _url = _interopRequireDefault(require("url"));

var _lodash3 = _interopRequireDefault(require("lodash.chunk"));

var _image = _interopRequireDefault(require("./image"));

var _marker = _interopRequireDefault(require("./marker"));

var _polyline = _interopRequireDefault(require("./polyline"));

var _multipolygon = _interopRequireDefault(require("./multipolygon"));

var _circle = _interopRequireDefault(require("./circle"));

var _text = _interopRequireDefault(require("./text"));

var _bound = _interopRequireDefault(require("./bound"));

var _asyncQueue = _interopRequireDefault(require("./helper/asyncQueue"));

var _geo = _interopRequireDefault(require("./helper/geo"));

var RENDER_CHUNK_SIZE = 1000;

var StaticMaps = /*#__PURE__*/function () {
  function StaticMaps() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, StaticMaps);
    this.options = options;
    this.width = this.options.width;
    this.height = this.options.height;
    this.paddingX = this.options.paddingX || 0;
    this.paddingY = this.options.paddingY || 0;
    this.padding = [this.paddingX, this.paddingY];
    this.tileUrl = 'tileUrl' in this.options ? this.options.tileUrl : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
    this.tileSize = this.options.tileSize || 256;
    this.tileSubdomains = this.options.tileSubdomains || this.options.subdomains || [];
    this.tileRequestTimeout = this.options.tileRequestTimeout;
    this.tileRequestHeader = this.options.tileRequestHeader;
    this.tileRequestLimit = Number.isFinite(this.options.tileRequestLimit) ? Number(this.options.tileRequestLimit) : 2;
    this.reverseY = this.options.reverseY || false;
    var zoomRange = this.options.zoomRange || {};
    this.zoomRange = {
      min: zoomRange.min || 1,
      max: this.options.maxZoom || zoomRange.max || 17 // maxZoom

    }; // this.maxZoom = this.options.maxZoom; DEPRECATED: use zoomRange.max instead
    // # features

    this.markers = [];
    this.lines = [];
    this.multipolygons = [];
    this.circles = [];
    this.text = [];
    this.bounds = []; // # fields that get set when map is rendered

    this.center = [];
    this.centerX = 0;
    this.centerY = 0;
    this.zoom = 0;
  }

  (0, _createClass2["default"])(StaticMaps, [{
    key: "addLine",
    value: function addLine(options) {
      this.lines.push(new _polyline["default"](options));
    }
  }, {
    key: "addMarker",
    value: function addMarker(options) {
      this.markers.push(new _marker["default"](options));
    }
  }, {
    key: "addPolygon",
    value: function addPolygon(options) {
      this.lines.push(new _polyline["default"](options));
    }
  }, {
    key: "addMultiPolygon",
    value: function addMultiPolygon(options) {
      this.multipolygons.push(new _multipolygon["default"](options));
    }
  }, {
    key: "addCircle",
    value: function addCircle(options) {
      this.circles.push(new _circle["default"](options));
    }
  }, {
    key: "addBound",
    value: function addBound(options) {
      this.bounds.push(new _bound["default"](options));
    }
  }, {
    key: "addText",
    value: function addText(options) {
      this.text.push(new _text["default"](options));
    }
    /**
      * Render static map with all map features that were added to map before
      */

  }, {
    key: "render",
    value: function () {
      var _render = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(center, zoom) {
        var maxZoom, extent, centerLon, centerLat;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!this.lines && !this.markers && !this.multipolygons && !(center && zoom))) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Cannot render empty map: Add  center || lines || markers || polygons.');

              case 2:
                this.center = center;
                this.zoom = zoom || this.calculateZoom();
                maxZoom = this.zoomRange.max;
                if (maxZoom && this.zoom > maxZoom) this.zoom = maxZoom;

                if (center && center.length === 2) {
                  this.centerX = _geo["default"].lonToX(center[0], this.zoom);
                  this.centerY = _geo["default"].latToY(center[1], this.zoom);
                } else {
                  // # get extent of all lines
                  extent = this.determineExtent(this.zoom); // # calculate center point of map

                  centerLon = (extent[0] + extent[2]) / 2;
                  centerLat = (extent[1] + extent[3]) / 2;
                  this.centerX = _geo["default"].lonToX(centerLon, this.zoom);
                  this.centerY = _geo["default"].latToY(centerLat, this.zoom);
                }

                this.image = new _image["default"](this.options);
                _context.next = 10;
                return Promise.all([this.drawBaselayer(), this.loadMarker()]);

              case 10:
                return _context.abrupt("return", this.drawFeatures());

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function render(_x, _x2) {
        return _render.apply(this, arguments);
      }

      return render;
    }()
    /**
      * calculate common extent of all current map features
      */

  }, {
    key: "determineExtent",
    value: function determineExtent(zoom) {
      var extents = []; // Add bbox to extent

      if (this.center && this.center.length >= 4) extents.push(this.center); // add bounds to extent

      if (this.bounds.length) {
        this.bounds.forEach(function (bound) {
          return extents.push(bound.extent());
        });
      } // Add polylines and polygons to extent


      if (this.lines.length) {
        this.lines.forEach(function (line) {
          extents.push(line.extent());
        });
      }

      if (this.multipolygons.length) {
        this.multipolygons.forEach(function (multipolygon) {
          extents.push(multipolygon.extent());
        });
      } // Add circles to extent


      if (this.circles.length) {
        this.circles.forEach(function (circle) {
          extents.push(circle.extent());
        });
      } // Add marker to extent


      for (var i = 0; i < this.markers.length; i++) {
        var marker = this.markers[i];
        var e = [marker.coord[0], marker.coord[1]];

        if (!zoom) {
          extents.push([marker.coord[0], marker.coord[1], marker.coord[0], marker.coord[1]]);
          continue;
        } // # consider dimension of marker


        var ePx = marker.extentPx();

        var x = _geo["default"].lonToX(e[0], zoom);

        var y = _geo["default"].latToY(e[1], zoom);

        extents.push([_geo["default"].xToLon(x - parseFloat(ePx[0]) / this.tileSize, zoom), _geo["default"].yToLat(y + parseFloat(ePx[1]) / this.tileSize, zoom), _geo["default"].xToLon(x + parseFloat(ePx[2]) / this.tileSize, zoom), _geo["default"].yToLat(y - parseFloat(ePx[3]) / this.tileSize, zoom)]);
      }

      return [Math.min.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[0];
      }))), Math.min.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[1];
      }))), Math.max.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[2];
      }))), Math.max.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[3];
      })))];
    }
    /**
      * calculate the best zoom level for given extent
      */

  }, {
    key: "calculateZoom",
    value: function calculateZoom() {
      for (var z = this.zoomRange.max; z >= this.zoomRange.min; z--) {
        var extent = this.determineExtent(z);
        var width = (_geo["default"].lonToX(extent[2], z) - _geo["default"].lonToX(extent[0], z)) * this.tileSize;
        if (width > this.width - this.padding[0] * 2) continue;
        var height = (_geo["default"].latToY(extent[1], z) - _geo["default"].latToY(extent[3], z)) * this.tileSize;
        if (height > this.height - this.padding[1] * 2) continue;
        return z;
      }

      return this.zoomRange.min;
    }
    /**
      * transform tile number to pixel on image canvas
      */

  }, {
    key: "xToPx",
    value: function xToPx(x) {
      var px = (x - this.centerX) * this.tileSize + this.width / 2;
      return Number(Math.round(px));
    }
    /**
      * transform tile number to pixel on image canvas
      */

  }, {
    key: "yToPx",
    value: function yToPx(y) {
      var px = (y - this.centerY) * this.tileSize + this.height / 2;
      return Number(Math.round(px));
    }
  }, {
    key: "drawBaselayer",
    value: function () {
      var _drawBaselayer = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var xMin, yMin, xMax, yMax, result, x, y, maxTile, tileX, tileY, tileUrl, quadKey, tiles;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.tileUrl) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", this.image.draw([]));

              case 2:
                xMin = Math.floor(this.centerX - 0.5 * this.width / this.tileSize);
                yMin = Math.floor(this.centerY - 0.5 * this.height / this.tileSize);
                xMax = Math.ceil(this.centerX + 0.5 * this.width / this.tileSize);
                yMax = Math.ceil(this.centerY + 0.5 * this.height / this.tileSize);
                result = [];

                for (x = xMin; x < xMax; x++) {
                  for (y = yMin; y < yMax; y++) {
                    // # x and y may have crossed the date line
                    maxTile = Math.pow(2, this.zoom);
                    tileX = (x + maxTile) % maxTile;
                    tileY = (y + maxTile) % maxTile;
                    if (this.reverseY) tileY = (1 << this.zoom) - tileY - 1;
                    tileUrl = void 0;

                    if (this.tileUrl.includes('{quadkey}')) {
                      quadKey = _geo["default"].tileXYToQuadKey(tileX, tileY, this.zoom);
                      tileUrl = this.tileUrl.replace('{quadkey}', quadKey);
                    } else {
                      tileUrl = this.tileUrl.replace('{z}', this.zoom).replace('{x}', tileX).replace('{y}', tileY);
                    }

                    if (this.tileSubdomains.length > 0) {
                      // replace subdomain with random domain from tileSubdomains array
                      tileUrl = tileUrl.replace('{s}', this.tileSubdomains[Math.floor(Math.random() * this.tileSubdomains.length)]);
                    }

                    result.push({
                      url: tileUrl,
                      box: [this.xToPx(x), this.yToPx(y), this.xToPx(x + 1), this.yToPx(y + 1)]
                    });
                  }
                }

                _context2.next = 10;
                return this.getTiles(result);

              case 10:
                tiles = _context2.sent;
                return _context2.abrupt("return", this.image.draw(tiles.filter(function (v) {
                  return v.success;
                }).map(function (v) {
                  return v.tile;
                })));

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function drawBaselayer() {
        return _drawBaselayer.apply(this, arguments);
      }

      return drawBaselayer;
    }()
  }, {
    key: "drawSVG",
    value: function () {
      var _drawSVG = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(features, svgFunction) {
        var chunks, baseImage, imageMetadata, processedChunks;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (features.length) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                // Chunk for performance
                chunks = (0, _lodash3["default"])(features, RENDER_CHUNK_SIZE);
                baseImage = (0, _sharp["default"])(this.image.image);
                _context3.next = 6;
                return baseImage.metadata();

              case 6:
                imageMetadata = _context3.sent;
                processedChunks = chunks.map(function (c) {
                  var svg = "\n        <svg\n          width=\"".concat(imageMetadata.width, "px\"\n          height=\"").concat(imageMetadata.height, "px\"\n          version=\"1.1\"\n          xmlns=\"http://www.w3.org/2000/svg\">\n          ").concat(c.map(function (f) {
                    return svgFunction(f);
                  }).join('\n'), "\n        </svg>\n      ");
                  return {
                    input: Buffer.from(svg),
                    top: 0,
                    left: 0
                  };
                });
                _context3.next = 10;
                return baseImage.composite(processedChunks).toBuffer();

              case 10:
                this.image.image = _context3.sent;

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function drawSVG(_x3, _x4) {
        return _drawSVG.apply(this, arguments);
      }

      return drawSVG;
    }()
    /**
     *  Render a circle to SVG
     */

  }, {
    key: "circleToSVG",
    value: function circleToSVG(circle) {
      var latCenter = circle.coord[1];

      var radiusInPixel = _geo["default"].meterToPixel(circle.radius, this.zoom, latCenter);

      var x = this.xToPx(_geo["default"].lonToX(circle.coord[0], this.zoom));
      var y = this.yToPx(_geo["default"].latToY(circle.coord[1], this.zoom));
      return "\n      <circle\n        cx=\"".concat(x, "\"\n        cy=\"").concat(y, "\"\n        r=\"").concat(radiusInPixel, "\"\n        style=\"fill-rule: inherit;\"\n        stroke=\"").concat(circle.color, "\"\n        fill=\"").concat(circle.fill, "\"\n        stroke-width=\"").concat(circle.width, "\"\n        />\n    ");
    }
    /**
     * Render text to SVG
     */

  }, {
    key: "textToSVG",
    value: function textToSVG(text) {
      var mapcoords = [this.xToPx(_geo["default"].lonToX(text.coord[0], this.zoom)) - text.offset[0], this.yToPx(_geo["default"].latToY(text.coord[1], this.zoom)) - text.offset[1]];
      return "\n      <text\n        x=\"".concat(mapcoords[0], "\"\n        y=\"").concat(mapcoords[1], "\"\n        style=\"fill-rule: inherit; font-family: ").concat(text.font, ";\"\n        font-size=\"").concat(text.size, "pt\"\n        stroke=\"").concat(text.color, "\"\n        fill=\"").concat(text.fill ? text.fill : 'none', "\"\n        stroke-width=\"").concat(text.width, "\"\n        text-anchor=\"").concat(text.anchor, "\"\n      >\n          ").concat(text.text, "\n      </text>\n    ");
    }
    /**
     *  Render MultiPolygon to SVG
     */

  }, {
    key: "multiPolygonToSVG",
    value: function multiPolygonToSVG(multipolygon) {
      var _this = this;

      var shapeArrays = multipolygon.coords.map(function (shape) {
        return shape.map(function (coord) {
          return [_this.xToPx(_geo["default"].lonToX(coord[0], _this.zoom)), _this.yToPx(_geo["default"].latToY(coord[1], _this.zoom))];
        });
      });
      var pathArrays = shapeArrays.map(function (points) {
        var startPoint = points.shift();
        var pathParts = ["M ".concat(startPoint[0], " ").concat(startPoint[1])].concat((0, _toConsumableArray2["default"])(points.map(function (p) {
          return "L ".concat(p[0], " ").concat(p[1]);
        })), ['Z']);
        return pathParts.join(' ');
      });
      return "<path\n      d=\"".concat(pathArrays.join(' '), "\"\n      style=\"fill-rule: inherit;\"\n      stroke=\"").concat(multipolygon.color, "\"\n      fill=\"").concat(multipolygon.fill ? multipolygon.fill : 'none', "\"\n      stroke-width=\"").concat(multipolygon.width, "\"/>");
    }
    /**
     *  Render Polyline to SVG
     */

  }, {
    key: "lineToSVG",
    value: function lineToSVG(line) {
      var _this2 = this;

      var points = line.coords.map(function (coord) {
        return [_this2.xToPx(_geo["default"].lonToX(coord[0], _this2.zoom)), _this2.yToPx(_geo["default"].latToY(coord[1], _this2.zoom))];
      });
      return "<".concat(line.type === 'polyline' ? 'polyline' : 'polygon', "\n              style=\"fill-rule: inherit;\"\n              points=\"").concat(points.join(' '), "\"\n              stroke=\"").concat(line.color, "\"\n              fill=\"").concat(line.fill ? line.fill : 'none', "\"\n              stroke-width=\"").concat(line.width, "\"/>");
    }
    /**
     *  Draw markers to the basemap
     */

  }, {
    key: "drawMarkers",
    value: function drawMarkers() {
      var _this3 = this;

      var queue = [];
      this.markers.forEach(function (marker) {
        queue.push( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
          var top, left;
          return _regenerator["default"].wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  top = Math.round(marker.position[1]);
                  left = Math.round(marker.position[0]);

                  if (!(top < 0 || left < 0 || top > _this3.height || left > _this3.width)) {
                    _context4.next = 4;
                    break;
                  }

                  return _context4.abrupt("return");

                case 4:
                  _context4.next = 6;
                  return (0, _sharp["default"])(_this3.image.image).composite([{
                    input: marker.imgData,
                    top: top,
                    left: left
                  }]).toBuffer();

                case 6:
                  _this3.image.image = _context4.sent;

                case 7:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        })));
      });
      return (0, _asyncQueue["default"])(queue);
    }
    /**
     *  Draw all features to the basemap
     */

  }, {
    key: "drawFeatures",
    value: function () {
      var _drawFeatures = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        var _this4 = this;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.drawSVG(this.lines, function (c) {
                  return _this4.lineToSVG(c);
                });

              case 2:
                _context5.next = 4;
                return this.drawSVG(this.multipolygons, function (c) {
                  return _this4.multiPolygonToSVG(c);
                });

              case 4:
                _context5.next = 6;
                return this.drawMarkers();

              case 6:
                _context5.next = 8;
                return this.drawSVG(this.text, function (c) {
                  return _this4.textToSVG(c);
                });

              case 8:
                _context5.next = 10;
                return this.drawSVG(this.circles, function (c) {
                  return _this4.circleToSVG(c);
                });

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function drawFeatures() {
        return _drawFeatures.apply(this, arguments);
      }

      return drawFeatures;
    }()
    /**
      *   Preloading the icon image
      */

  }, {
    key: "loadMarker",
    value: function loadMarker() {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        if (!_this5.markers.length) resolve(true);
        var icons = (0, _lodash2["default"])(_this5.markers.map(function (m) {
          return {
            file: m.img
          };
        }), 'file');
        var count = 1;
        icons.forEach( /*#__PURE__*/function () {
          var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(ico) {
            var icon, isUrl, img;
            return _regenerator["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    icon = ico;
                    isUrl = !!_url["default"].parse(icon.file).hostname;
                    _context6.prev = 2;

                    if (!isUrl) {
                      _context6.next = 12;
                      break;
                    }

                    _context6.next = 6;
                    return _got["default"].get({
                      https: {
                        rejectUnauthorized: false
                      },
                      url: icon.file,
                      responseType: 'buffer'
                    });

                  case 6:
                    img = _context6.sent;
                    _context6.next = 9;
                    return (0, _sharp["default"])(img.body).toBuffer();

                  case 9:
                    icon.data = _context6.sent;
                    _context6.next = 15;
                    break;

                  case 12:
                    _context6.next = 14;
                    return (0, _sharp["default"])(icon.file).toBuffer();

                  case 14:
                    icon.data = _context6.sent;

                  case 15:
                    _context6.next = 20;
                    break;

                  case 17:
                    _context6.prev = 17;
                    _context6.t0 = _context6["catch"](2);
                    reject(_context6.t0);

                  case 20:
                    if (count++ === icons.length) {
                      // Pre loaded all icons
                      _this5.markers.forEach(function (mark) {
                        var marker = mark;
                        marker.position = [_this5.xToPx(_geo["default"].lonToX(marker.coord[0], _this5.zoom)) - marker.offset[0], _this5.yToPx(_geo["default"].latToY(marker.coord[1], _this5.zoom)) - marker.offset[1]];
                        var imgData = (0, _lodash["default"])(icons, {
                          file: marker.img
                        });
                        marker.set(imgData.data);
                      });

                      resolve(true);
                    }

                  case 21:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, null, [[2, 17]]);
          }));

          return function (_x5) {
            return _ref2.apply(this, arguments);
          };
        }());
      });
    }
    /**
     *  Fetching tile from endpoint
     */

  }, {
    key: "getTile",
    value: function () {
      var _getTile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(data) {
        var options, res, body, headers, contentType;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = {
                  url: data.url,
                  responseType: 'buffer',
                  // resolveWithFullResponse: true,
                  headers: this.tileRequestHeader || {},
                  timeout: this.tileRequestTimeout
                };
                _context7.prev = 1;
                _context7.next = 4;
                return _got["default"].get(options);

              case 4:
                res = _context7.sent;
                body = res.body, headers = res.headers;
                contentType = headers['content-type'];

                if (contentType.startsWith('image/')) {
                  _context7.next = 9;
                  break;
                }

                throw new Error('Tiles server response with wrong data');

              case 9:
                return _context7.abrupt("return", {
                  success: true,
                  tile: {
                    url: data.url,
                    box: data.box,
                    body: body
                  }
                });

              case 12:
                _context7.prev = 12;
                _context7.t0 = _context7["catch"](1);
                return _context7.abrupt("return", {
                  success: false,
                  error: _context7.t0
                });

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[1, 12]]);
      }));

      function getTile(_x6) {
        return _getTile.apply(this, arguments);
      }

      return getTile;
    }()
    /**
     *  Fetching tiles and limit concurrent connections
     */

  }, {
    key: "getTiles",
    value: function () {
      var _getTiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(baseLayers) {
        var _this6 = this;

        var limit, _ret, tilePromises;

        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                limit = this.tileRequestLimit; // Limit concurrent connections to tiles server
                // https://operations.osmfoundation.org/policies/tiles/#technical-usage-requirements

                if (!Number(limit)) {
                  _context11.next = 6;
                  break;
                }

                return _context11.delegateYield( /*#__PURE__*/_regenerator["default"].mark(function _callee10() {
                  var aQueue, tiles, _loop, i, j;

                  return _regenerator["default"].wrap(function _callee10$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          aQueue = [];
                          tiles = [];

                          _loop = function _loop(i, j) {
                            var chunks = baseLayers.slice(i, i + limit);
                            var sQueue = [];
                            aQueue.push( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
                              return _regenerator["default"].wrap(function _callee9$(_context9) {
                                while (1) {
                                  switch (_context9.prev = _context9.next) {
                                    case 0:
                                      chunks.forEach(function (r) {
                                        sQueue.push((0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
                                          var tile;
                                          return _regenerator["default"].wrap(function _callee8$(_context8) {
                                            while (1) {
                                              switch (_context8.prev = _context8.next) {
                                                case 0:
                                                  _context8.next = 2;
                                                  return _this6.getTile(r);

                                                case 2:
                                                  tile = _context8.sent;
                                                  tiles.push(tile);

                                                case 4:
                                                case "end":
                                                  return _context8.stop();
                                              }
                                            }
                                          }, _callee8);
                                        }))());
                                      });
                                      _context9.next = 3;
                                      return Promise.all(sQueue);

                                    case 3:
                                    case "end":
                                      return _context9.stop();
                                  }
                                }
                              }, _callee9);
                            })));
                          };

                          for (i = 0, j = baseLayers.length; i < j; i += limit) {
                            _loop(i, j);
                          }

                          _context10.next = 6;
                          return (0, _asyncQueue["default"])(aQueue);

                        case 6:
                          return _context10.abrupt("return", {
                            v: tiles
                          });

                        case 7:
                        case "end":
                          return _context10.stop();
                      }
                    }
                  }, _callee10);
                })(), "t0", 3);

              case 3:
                _ret = _context11.t0;

                if (!((0, _typeof2["default"])(_ret) === "object")) {
                  _context11.next = 6;
                  break;
                }

                return _context11.abrupt("return", _ret.v);

              case 6:
                // Do not limit concurrent connections at all
                tilePromises = [];
                baseLayers.forEach(function (r) {
                  tilePromises.push(_this6.getTile(r));
                });
                return _context11.abrupt("return", Promise.all(tilePromises));

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getTiles(_x7) {
        return _getTiles.apply(this, arguments);
      }

      return getTiles;
    }()
  }]);
  return StaticMaps;
}();

var _default = StaticMaps;
exports["default"] = _default;
module.exports = StaticMaps;