"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getLatestTag_exports = {};
__export(getLatestTag_exports, {
  getAllUrls: () => getAllUrls,
  getLatestTag: () => getLatestTag,
  urlExists: () => urlExists
});
module.exports = __toCommonJS(getLatestTag_exports);
var import_get_platform = require("@prisma/get-platform");
var import_chalk = __toESM(require("chalk"));
var import_execa = __toESM(require("execa"));
var import_node_fetch = __toESM(require("node-fetch"));
var import_p_map = __toESM(require("p-map"));
var import_getProxyAgent = require("./getProxyAgent");
var import_utils = require("./utils");
async function getLatestTag() {
  let branch = await getBranch();
  if (branch !== "main" && !isPatchBranch(branch) && !branch.startsWith("integration/")) {
    branch = "main";
  }
  branch = branch.replace(/^integration\//, "");
  let commits = await getCommits(branch);
  if ((!commits || !Array.isArray(commits)) && branch !== "main" && !isPatchBranch(branch)) {
    console.log(`Overwriting branch "${branch}" with "main" as it's not a branch we have binaries for`);
    branch = "main";
    commits = await getCommits(branch);
  }
  if (!Array.isArray(commits)) {
    console.error(commits);
    throw new Error(`Could not fetch commits from github: ${JSON.stringify(commits, null, 2)}`);
  }
  return getFirstFinishedCommit(branch, commits);
}
__name(getLatestTag, "getLatestTag");
function getAllUrls(branch, commit) {
  const urls = [];
  const excludedPlatforms = [
    "freebsd",
    "arm",
    "linux-nixos",
    "linux-arm-openssl-1.1.x",
    "linux-arm-openssl-1.0.x",
    "linux-arm-openssl-3.0.x",
    "openbsd",
    "netbsd",
    "freebsd11",
    "freebsd12",
    "freebsd13"
  ];
  const relevantPlatforms = import_get_platform.platforms.filter((p) => !excludedPlatforms.includes(p));
  for (const platform of relevantPlatforms) {
    for (const engine of ["query-engine", "introspection-engine", "migration-engine", "prisma-fmt"]) {
      for (const extension of [".gz", ".gz.sha256", ".gz.sig", ".sig", ".sha256"]) {
        const downloadUrl = (0, import_utils.getDownloadUrl)(branch, commit, platform, engine, extension);
        urls.push(downloadUrl);
      }
    }
  }
  return urls;
}
__name(getAllUrls, "getAllUrls");
async function getFirstFinishedCommit(branch, commits) {
  for (const commit of commits) {
    const urls = getAllUrls(branch, commit);
    const exist = await (0, import_p_map.default)(urls, urlExists, { concurrency: 10 });
    const hasMissing = exist.some((e) => !e);
    if (!hasMissing) {
      return commit;
    } else {
      const missing = urls.filter((_, i) => !exist[i]);
      if (missing.length !== urls.length) {
        console.log(
          `${import_chalk.default.blueBright(
            "info"
          )} The engine commit ${commit} is not yet done. We're skipping it as we're in dev. Missing urls: ${missing.length}`
        );
      }
    }
  }
}
__name(getFirstFinishedCommit, "getFirstFinishedCommit");
async function urlExists(url) {
  try {
    const res = await (0, import_node_fetch.default)(url, {
      method: "HEAD",
      agent: (0, import_getProxyAgent.getProxyAgent)(url)
    });
    const headers = fromEntries(res.headers.entries());
    if (res.status > 200) {
    }
    if (parseInt(headers["content-length"]) > 0) {
      return res.status < 300;
    }
  } catch (e) {
  }
  return false;
}
__name(urlExists, "urlExists");
function fromEntries(entries) {
  const result = {};
  for (const [key, value] of entries) {
    result[key] = value;
  }
  return result;
}
__name(fromEntries, "fromEntries");
async function getBranch() {
  if (process.env.NODE_ENV !== "test") {
    if (process.env.PATCH_BRANCH) {
      return process.env.PATCH_BRANCH;
    }
    if (process.env.BUILDKITE_BRANCH) {
      return process.env.BUILDKITE_BRANCH;
    }
    if (process.env.GITHUB_CONTEXT) {
      const context = JSON.parse(process.env.GITHUB_CONTEXT);
      return context.head_ref;
    }
  }
  try {
    const result = await import_execa.default.command("git rev-parse --abbrev-ref HEAD", {
      shell: true,
      stdio: "pipe"
    });
    return result.stdout;
  } catch (e) {
    console.error(e);
  }
  return;
}
__name(getBranch, "getBranch");
function isPatchBranch(version) {
  return /^2\.(\d+)\.x/.test(version);
}
__name(isPatchBranch, "isPatchBranch");
async function getCommits(branch) {
  const url = `https://github-cache.prisma.workers.dev/repos/prisma/prisma-engines/commits?sha=${branch}`;
  const result = await (0, import_node_fetch.default)(url, {
    agent: (0, import_getProxyAgent.getProxyAgent)(url)
  }).then((res) => res.json());
  if (!Array.isArray(result)) {
    return result;
  }
  const commits = result.map((r) => r.sha);
  return commits;
}
__name(getCommits, "getCommits");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getAllUrls,
  getLatestTag,
  urlExists
});
