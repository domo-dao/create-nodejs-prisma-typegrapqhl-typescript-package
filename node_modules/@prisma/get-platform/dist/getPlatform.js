"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getPlatform_exports = {};
__export(getPlatform_exports, {
  getOpenSSLVersion: () => getOpenSSLVersion,
  getPlatform: () => getPlatform,
  getos: () => getos,
  parseDistro: () => parseDistro,
  parseOpenSSLVersion: () => parseOpenSSLVersion,
  resolveDistro: () => resolveDistro
});
module.exports = __toCommonJS(getPlatform_exports);
var import_child_process = require("child_process");
var import_fs = __toESM(require("fs"));
var import_os = __toESM(require("os"));
var import_util = require("util");
const readFile = (0, import_util.promisify)(import_fs.default.readFile);
const exists = (0, import_util.promisify)(import_fs.default.exists);
async function getos() {
  const platform = import_os.default.platform();
  const arch = process.arch;
  if (platform === "freebsd") {
    const version = await gracefulExec(`freebsd-version`);
    if (version && version.trim().length > 0) {
      const regex = /^(\d+)\.?/;
      const match = regex.exec(version);
      if (match) {
        return {
          platform: "freebsd",
          distro: `freebsd${match[1]}`,
          arch
        };
      }
    }
  }
  if (platform !== "linux") {
    return {
      platform,
      arch
    };
  }
  return {
    platform: "linux",
    libssl: await getOpenSSLVersion(),
    distro: await resolveDistro(),
    arch
  };
}
__name(getos, "getos");
function parseDistro(input) {
  const idRegex = /^ID="?([^"\n]*)"?$/im;
  const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
  const idMatch = idRegex.exec(input);
  const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
  const idLikeMatch = idLikeRegex.exec(input);
  const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
  if (id === "raspbian") {
    return "arm";
  }
  if (id === "nixos") {
    return "nixos";
  }
  if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
    return "rhel";
  }
  if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
    return "debian";
  }
  return;
}
__name(parseDistro, "parseDistro");
async function resolveDistro() {
  const osReleaseFile = "/etc/os-release";
  const alpineReleaseFile = "/etc/alpine-release";
  if (await exists(alpineReleaseFile)) {
    return "musl";
  } else if (await exists(osReleaseFile)) {
    return parseDistro(await readFile(osReleaseFile, "utf-8"));
  } else {
    return;
  }
}
__name(resolveDistro, "resolveDistro");
function parseOpenSSLVersion(input) {
  const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
  if (match) {
    return match[1] + ".x";
  }
  return;
}
__name(parseOpenSSLVersion, "parseOpenSSLVersion");
async function getOpenSSLVersion() {
  const [version, ls] = await Promise.all([
    gracefulExec(`openssl version -v`),
    gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
  ]);
  if (version) {
    const v = parseOpenSSLVersion(version);
    if (v) {
      return v;
    }
  }
  if (ls) {
    const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
    if (match) {
      return match[1] + ".x";
    }
  }
  return void 0;
}
__name(getOpenSSLVersion, "getOpenSSLVersion");
async function gracefulExec(cmd) {
  return new Promise((resolve) => {
    try {
      (0, import_child_process.exec)(cmd, (err, stdout) => {
        resolve(String(stdout));
      });
    } catch (e) {
      resolve(void 0);
      return void 0;
    }
    return void 0;
  });
}
__name(gracefulExec, "gracefulExec");
async function getPlatform() {
  const { platform, libssl, distro, arch } = await getos();
  if (platform === "darwin" && arch === "arm64") {
    return "darwin-arm64";
  }
  if (platform === "darwin") {
    return "darwin";
  }
  if (platform === "win32") {
    return "windows";
  }
  if (platform === "freebsd") {
    return distro;
  }
  if (platform === "openbsd") {
    return "openbsd";
  }
  if (platform === "netbsd") {
    return "netbsd";
  }
  if (platform === "linux" && distro === "nixos") {
    return "linux-nixos";
  }
  if (platform === "linux" && arch === "arm64") {
    return `linux-arm64-openssl-${libssl}`;
  }
  if (platform === "linux" && arch === "arm") {
    return `linux-arm-openssl-${libssl}`;
  }
  if (platform === "linux" && distro === "musl") {
    return "linux-musl";
  }
  if (platform === "linux" && distro && libssl) {
    return distro + "-openssl-" + libssl;
  }
  if (libssl) {
    return "debian-openssl-" + libssl;
  }
  if (distro) {
    return distro + "-openssl-1.1.x";
  }
  return "debian-openssl-1.1.x";
}
__name(getPlatform, "getPlatform");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getOpenSSLVersion,
  getPlatform,
  getos,
  parseDistro,
  parseOpenSSLVersion,
  resolveDistro
});
